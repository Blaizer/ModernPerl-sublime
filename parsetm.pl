=head1 NAME

parsetm.pl - parse tmLanguage files between XML and YAML

=head1 SYNOPSIS

 perl parsetm.pl [OUTFILE] [INFILE]
 perl parsetm.pl OUTFILE.yaml [INFILE]

=head1 OPTIONS

This script has two different modes. The default mode takes a YAML C<INFILE> and
outputs an XML C<OUTFILE>. In this mode the default C<OUTFILE> is
-Perl.tmLanguage and the default C<INFILE> is -Perl.tmLanguage.yaml. If
C<OUTFILE> exists it will be overwritten.

When C<OUTFILE> ends in .yaml or .yml the script instead takes an XML C<INFILE>
and outputs a YAML C<OUTFILE>. In this mode the default C<INFILE> is
Perl.tmLanguage. If C<OUTFILE> exists it will never be overwritten. Remove the
file first before running this script. This mode requires XML::Parser to be
installed.

Both modes require YAML::Any to be installed.

=cut

use 5.01;
use strict;
use warnings;
use Data::Dumper;
use YAML::Any qw/DumpFile Load/;
use Scalar::Util qw/looks_like_number/;
use autodie;
sub parse;
sub unparse;

my $outfile = $ARGV[0] // "-Perl.tmLanguage";
my $infile  = $ARGV[1];

if ($outfile =~ /\.ya?ml$/i) {
	-e $outfile and exit say "$outfile exists. Won't overwrite.";
	require XML::Parser;
	$infile //= "Perl.tmLanguage";
	my $p = XML::Parser->new(Style => "Tree");
	my $tree = $p->parsefile($infile);
	my @parsed = parse @$tree;
	DumpFile $outfile, @parsed;
}
else {
	$infile //= "-Perl.tmLanguage.yaml";
	open IN, "<", $infile;
	local $/;
	my $file = <IN>;
	close IN;
	$file =~ s/(?:^|\G)\t/ /gm; # make the file valid YAML by replacing tabs with spaces

	# search for some common mistakes
	while ($file =~
		m{
			\G [\d\D]*? ^
			(
				(\h+) \w+\h*:\h+ ([|>]) (-?) .*\n

 				\2\h+ (\(\? [a-z]*x[a-z-]* \))? .*\n

				(?> \2\h+ .*\n )*
			)
		}gmx
	) {
		my ($lines, $taker, $minus, $x) = ($1, $3, $4, $5);
		my $multiline = $lines =~ /\n.*\n.*\n/;

		my $bad;
		if ($multiline and !$x) {
			$bad = say "Can't multiline non x";
		}
		if ($taker eq ">" and $x) {
			$bad = say "Can't x > because you can't use comments";
		}
		if ($minus and $x) {
			$bad = say "x looks better without -";
		}
		if (!$minus and !$multiline) {
			$bad = say "Probably should be using -";
		}
		if ($bad) {
			print $lines;
		}
	}

	my ($tree) = Load $file;
	my $unparsed = unparse $tree, 1;
	$unparsed =~ s/\n$//; # chomp
	my $xml = <<"XML";
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<!--
This file was generated automatically by $0 from $infile.
Do not edit this file directly. Instead, use $0 to generate it.
-->
<plist version="1.0">
$unparsed
</plist>
XML
	open OUT, ">", $outfile;
	print OUT $xml;
	close OUT;
}

sub unparse {
	my $item = shift;
	my $level = shift;
	my $indent = "\t" x $level;
	my $a = $indent;

	if (!ref $item) {
		my $tag = shift;
		if (!defined $tag) {
			print "no tag: " . Data::Dumper->Dump([$item], ["value"]);
			return "";
		}

		$item //= '';
		$item =~ s/(^|\G) /\t/gm; # opposite of what we did before
		$item =~ s/\n/\n$indent/g;

		my $orig_item = $item;
		$item =~ s/&/&amp;/g;
		$item =~ s/</&lt;/g;
		$item =~ s/>/&gt;/g;
		# use CDATA unless it costs us more characters than not using it
		if (length($item) - length $orig_item >= length "<![CDATA[]]>") {
			$item = "<![CDATA[$orig_item]]>" if $orig_item !~ /]]>/;
		}

		$a .= "<$tag>$item</$tag>";
	}
	elsif (ref $item eq "HASH") {
		$a .= "<dict>\n";
		for my $key (sort keys %$item)
		{
			my $level = $level + 1;
			$a .= unparse $key, $level, "key";

			my $value = $item->{$key};
			my $tag = "string";

			if ($key eq "applyEndPatternLast") {
				unless (looks_like_number $value and int $value == $value) {
					print "bad integer: " . Data::Dumper->Dump([$value], [$key]);
				}
				{ no warnings; $value = int $value }
				$tag = "integer";
			}

			$a .= unparse $value, $level, $tag;
		}
		$a .= "$indent</dict>";
	}
	elsif (ref $item eq "ARRAY") {
		$a .= "<array>\n";
		for my $value (@$item) {
			$a .= unparse $value, $level + 1, "string";
		}
		$a .= "$indent</array>";
	}
	else {
		print "unexpected: " . Data::Dumper->Dump([$item], ["item"]);
		return "";
	}

	return $a . "\n";
}

sub parse {
	return if !@_;
	my @a;

	for (my $i = 0; $i < @_; $i += 4) {
		my $name = $_[$i];
		my $list = $_[$i + 1];

		my (undef, undef, $content, @inner) = @$list;
		if ($name eq "string" or $name eq "key" or $name eq "integer") {
			push @a, $content;
		}
		elsif ($name eq "dict") {
			push @a, { parse @inner };
		}
		elsif ($name eq "array") {
			push @a, [ parse @inner ];
		}
		else {
			say "skipped: $name";
			push @a, parse @inner;
		}
	}

	return @a;
}
