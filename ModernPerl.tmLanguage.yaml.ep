%#
%# This is Extended Perl (EP) but you should view it with a YAML syntax highlighter
%# EP is a template language that lets us use Perl to preprocess text (in this case YAML)
%# For a guide to EP, see http://mojolicio.us/perldoc/Mojolicious/Guides/Rendering#Embedded_Perl
%#
---
name: ModernPerl
scopeName: source.perl
comment: Blaise Roth <blaizer@cpan.org>
uuid: 2c338cc8-a464-4ee4-a56c-d524947fa6f9
fileTypes:
- pl
- PL
- pm
- pod
- t
firstLineMatch: |-
    ^#!.*\bperl\b
patterns:
- include: '#line_comment'
- include: '#pod'
- include: '#variable'
-
    begin: |-
        \b(?=qr\s*[^\s\w])
    end: |-
        ((([\p{Lower}]*)))(?=(\s+\S|\s*[;\,\#\{\}\)]|$))
    endCaptures:
        1: { name: string.regexp.compile.perl }
        2: { name: punctuation.definition.string.perl }
        3: { name: keyword.control.regexp-option.perl }
    patterns:
    -
        begin: |-
            (qr)\s*\{
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '\}'
        name: string.regexp.compile.nested_braces.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_braces_interpolated'
    -
        begin: |-
            (qr)\s*\[
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: ']'
        name: string.regexp.compile.nested_brackets.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_brackets_interpolated'
    -
        begin: |-
            (qr)\s*<
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '>'
        name: string.regexp.compile.nested_ltgt.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_ltgt_interpolated'
    -
        begin: |-
            (qr)\s*\(
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '\)'
        name: string.regexp.compile.nested_parens.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_parens_interpolated'
    -
        begin: |-
            (qr)\s*\'
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: "'"
        name: string.regexp.compile.single-quote.perl
        patterns:
        - include: '#escaped_char'
    -
        begin: |-
            (qr)\s*([^\s\w\'\{\[\(\<])
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '\2'
        name: string.regexp.compile.simple-delimiter.perl
        patterns:
        -
            comment: This is to prevent thinks like qr/foo$/ to treat $/ as a variable
            match: |-
                \$(?=[^\s\w\'\{\[\(\<])
            name: keyword.control.anchor.perl
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_parens_interpolated'
-
    begin: |-
        \b(?=(?<!\&)(s)(\s+\S|\s*[;\,\#\{\}\(\)\[<]|$))
    end: |-
        ((([\p{Lower}]*)))(?=(\s+\S|\s*[;\,\#\{\}\)\]>]|$))
    endCaptures:
        1: { name: string.regexp.replace.perl }
        2: { name: punctuation.definition.string.perl }
        3: { name: keyword.control.regexp-option.perl }
    patterns:
    -
        begin: |-
            (s)\s*\{
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '\}'
        name: string.regexp.nested_braces.perl
        patterns:
        - include: '#escaped_char'
        - include: '#nested_braces'
    -
        begin: |-
            (s)\s*\[
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: ']'
        name: string.regexp.nested_brackets.perl
        patterns:
        - include: '#escaped_char'
        - include: '#nested_brackets'
    -
        begin: |-
            (s)\s*<
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '>'
        name: string.regexp.nested_ltgt.perl
        patterns:
        - include: '#escaped_char'
        - include: '#nested_ltgt'
    -
        begin: |-
            (s)\s*\(
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: '\)'
        name: string.regexp.nested_parens.perl
        patterns:
        - include: '#escaped_char'
        - include: '#nested_parens'
    -
        begin: '\{'
        captures:
            0: { name: punctuation.definition.string.perl }
        end: '\}'
        name: string.regexp.format.nested_braces.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_braces_interpolated'
    -
        begin: '\['
        captures:
            0: { name: punctuation.definition.string.perl }
        end: ']'
        name: string.regexp.format.nested_brackets.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_brackets_interpolated'
    -
        begin: '<'
        captures:
            0: { name: punctuation.definition.string.perl }
        end: '>'
        name: string.regexp.format.nested_ltgt.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_ltgt_interpolated'
    -
        begin: '\('
        captures:
            0: { name: punctuation.definition.string.perl }
        end: '\)'
        name: string.regexp.format.nested_parens.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_parens_interpolated'
    -
        begin: "'"
        captures:
            0: { name: punctuation.definition.string.perl }
        end: "'"
        name: string.regexp.format.single_quote.perl
        patterns:
        -
            match: |-
                \\['\\]
            name: constant.character.escape.perl
    -
        begin: |-
            ([^\s\w\[({<;])
        captures:
            0: { name: punctuation.definition.string.perl }
        end: '\1'
        name: string.regexp.format.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
    -
        match: '\s+'
-
    begin: |-
        \b(?=s([^\s\w\[({<]).*\1([\p{Lower}]*)([\}\)\;\,]|\s+))
    comment: string.regexp.replaceXXX
    end: |-
        ((([\p{Lower}]*)))(?=([\}\)\;\,]|\s+|$))
    endCaptures:
        1: { name: string.regexp.replace.perl }
        2: { name: punctuation.definition.string.perl }
        3: { name: keyword.control.regexp-option.perl }
    patterns:
    -
        begin: |-
            (s\s*)([^\s\w\[({<])
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: |-
            (?=\2)
        name: string.regexp.replaceXXX.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
    -
        begin: "'"
        captures:
            0: { name: punctuation.definition.string.perl }
        end: "'"
        name: string.regexp.replaceXXX.format.single_quote.perl
        patterns:
        -
            match: |-
                \\['\\]
            name: constant.character.escape.perl.perl
    -
        begin: |-
            ([^\s\w\[({<])
        captures:
            0: { name: punctuation.definition.string.perl }
        end: '\1'
        name: string.regexp.replaceXXX.format.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
-
    begin: |-
        \b(?=(?<!\\)s\s*([^\s\w\[({<]))
    comment: string.regexp.replace.extended
    end: |-
        \2((([\p{Lower}]*x[\p{Lower}]*)))\b
    endCaptures:
        1: { name: string.regexp.replace.perl }
        2: { name: punctuation.definition.string.perl }
        3: { name: keyword.control.regexp-option.perl }
    patterns:
    -
        begin: |-
            (s)\s*(.)
        captures:
            0: { name: punctuation.definition.string.perl }
            1: { name: support.function.perl }
        end: |-
            (?=\2)
        name: string.regexp.replace.extended.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
    -
        begin: "'"
        captures:
            0: { name: punctuation.definition.string.perl }
        end: |-
            '(?=[\p{Lower}]*x[\p{Lower}]*)\b
        name: string.regexp.replace.extended.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
    -
        begin: '(.)'
        captures:
            0: { name: punctuation.definition.string.perl }
        end: |-
            \1(?=[\p{Lower}]*x[\p{Lower}]*)\b
        name: string.regexp.replace.extended.simple_delimiter.perl
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
-
    match: |-
        (?:\b|-)[\w&&\D]\w*\s*(?==>)
    name: constant.language.string.perl
-
    captures:
        1: { name: constant.language.string.perl }
    match: |
        (?x)
        {
        (?! \s+ -?[\w&&\D]\w* \s+) # can't have spaces on both sides
        (\s*-?[\w&&\D]\w*\s*)
        }
    name: meta.bareword.braced.perl
-
    captures:
        1: { name: punctuation.definition.string.perl }
        5: { name: punctuation.definition.string.perl }
    match: |-
        (?<!\\)((~\s*)?\/)(\S.*?)(?<!\\)(\\{2})*(\/)
    name: string.regexp.find.perl
-
    begin: |-
        (?<!\\)(\~\s*\/)
    captures:
        0: { name: punctuation.definition.string.perl }
    end: |-
        \/([\p{Lower}]*x[\p{Lower}]*)\b
    endCaptures:
        1: { name: keyword.control.regexp-option.perl }
    name: string.regexp.find.extended.perl
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
- include: '#ampersand_sub'
- include: '#other_sigil'
-
    captures:
        1: { name: support.function.perl }
        2: { name: punctuation.definition.string.perl }
        5: { name: punctuation.definition.string.perl }
    match: |-
        \b(m)\s*(?<!\\)([^\[\{\(\w\s])(.*?)(?<!\\)(\\{2})*(\2)
    name: string.regexp.find-m.perl
-
    begin: |-
        \b(m)\s*(?<!\\)\(
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\)'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.regexp.find-m-paren.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_parens_interpolated'
    - include: '#variable'
-
    begin: |-
        \b(m)\s*(?<!\\)\{
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\}'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.regexp.find-m-brace.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_braces_interpolated'
    - include: '#variable'
-
    begin: |-
        \b(m)\s*(?<!\\)\[
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: ']'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.regexp.find-m-bracket.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_brackets_interpolated'
    - include: '#variable'
-
    begin: |-
        \b(m)\s*(?<!\\)\<
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '>'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.regexp.find-m-ltgt.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_ltgt_interpolated'
    - include: '#variable'
-
    captures:
        1: { name: support.function.perl }
        2: { name: punctuation.definition.string.perl }
        5: { name: punctuation.definition.string.perl }
        8: { name: punctuation.definition.string.perl }
    match: |-
        \b(s|tr|y)\s*([^\w\s])(.*?)(?<!\\)(\\{2})*(\2)(.*?)(?<!\\)(\\{2})*(\2)
    name: string.regexp.replace.perl
-
    match: |-
        \b(__FILE__|__LINE__|__PACKAGE__|__SUB__)(?!\w|::)
    name: constant.language.compiler-token.perl
-
    captures:
        1: { name: keyword.control.labelled.perl }
        2: { name: constant.language.label.perl }
    match: |
        (?x)
        \b (dump|goto|last|next|redo) (?!\w|::)
        #
        (?:
            # open parens or space
            (?: \s+ | \s*(?: \(\s* )+ )
            #
            # LABEL
            ([\w&&\D&&\P{Lower}][\w&&\P{Lower}]*) (?!\w|::|'\w)
        )?
    name: meta.control.labelled.perl
-
    match: |-
        \b(break|continue|default|die|do|dump|else|elsif|eval|exit|for|foreach|given|goto|if|last|next|redo|return|unless|until|when|while)(?!\w|::)
    name: keyword.control.perl
-
    match: |-
        \b(local|my|our|state)(?!\w|::)
    name: storage.modifier.perl
    captures:
        0: { name: variable.parameter.type.perl }
-
    match: |-
        \b(and|cmp|or|xor|not|lt|gt|le|ge|eq|ne|x)(?!\w|::)
    name: keyword.operator.named.perl
-
    begin: |-
        ((<<) *"([^"]*)").*\n?
    captures:
        0: { name: punctuation.definition.string.perl }
        1: { name: string.unquoted.heredoc.doublequote.perl }
        2: { name: punctuation.definition.heredoc.perl }
    contentName: string.unquoted.heredoc.doublequote.perl
    end: |-
        (^\3$)
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        ((<<) *'([^']*)').*\n?
    captures:
        0: { name: punctuation.definition.string.perl }
        1: { name: string.unquoted.heredoc.quote.perl }
        2: { name: punctuation.definition.heredoc.perl }
    contentName: string.unquoted.heredoc.quote.perl
    end: |-
        (^\3$)
-
    begin: |-
        ((<<) *`([^`]*)`).*\n?
    captures:
        0: { name: punctuation.definition.string.perl }
        1: { name: string.unquoted.heredoc.backtick.perl }
        2: { name: punctuation.definition.heredoc.perl }
    contentName: string.unquoted.heredoc.backtick.perl
    end: |-
        (^\3$)
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        ((<<) *((?![=\d\$ ])[^;,'"`\s)]*)).*\n?
    captures:
        0: { name: punctuation.definition.string.perl }
        1: { name: string.unquoted.heredoc.perl }
        2: { name: punctuation.definition.heredoc.perl }
    contentName: string.unquoted.heredoc.perl
    end: |-
        (^\3$)
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        \bqq\s*([^\(\{\[\<\w\s])
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\1'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.qq.perl
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        \bqx\s*([^'\(\{\[\<\w\s])
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\1'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx.perl
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        \bqx\s*'
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: "'"
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx.single-quote.perl
    patterns:
    - include: '#escaped_char'
-
    begin: '"'
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '"'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.double.perl
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        \bqw?\s*([^\(\{\[\<\w\s])
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\1'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.q.perl
    patterns:
    - include: '#escaped_char'
-
    begin: "(')"
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\1'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.single.perl
    patterns:
    -
        match: |-
            \\['\\]
        name: constant.character.escape.perl
-
    begin: '`'
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '`'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.perl
    patterns:
    - include: '#escaped_char'
    - include: '#variable'
-
    begin: |-
        \bqq\s*\(
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\)'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.qq-paren.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_parens_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqq\s*\{
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\}'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.qq-brace.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_braces_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqq\s*\[
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: ']'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.qq-bracket.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_brackets_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqq\s*\<
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '>'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.qq-ltgt.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_ltgt_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqx\s*\(
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\)'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx-paren.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_parens_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqx\s*\{
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\}'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx-brace.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_braces_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqx\s*\[
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: ']'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx-bracket.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_brackets_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqx\s*\<
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '>'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.interpolated.qx-ltgt.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_ltgt_interpolated'
    - include: '#variable'
-
    begin: |-
        \bqw?\s*\(
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\)'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.q-paren.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_parens'
-
    begin: |-
        \bqw?\s*\{
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '\}'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.q-brace.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_braces'
-
    begin: |-
        \bqw?\s*\[
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: ']'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.q-bracket.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_brackets'
-
    begin: |-
        \bqw?\s*\<
    beginCaptures:
        0: { name: punctuation.definition.string.begin.perl }
    end: '>'
    endCaptures:
        0: { name: punctuation.definition.string.end.perl }
    name: string.quoted.other.q-ltgt.perl
    patterns:
    - include: '#escaped_char'
    - include: '#nested_ltgt'
-
    begin: |-
        \b(__END__|__DATA__)(?!\w|::)
    beginCaptures:
        1: { name: comment.block.arbitrary.start }
    end: |-
        (?!^)^
    name: comment.block.aribtrary.perl
    patterns:
    - include: '#pod'
-
    match: |
        (?x)
        (?<! [<])
        <
        (?! [\s=] )
        (?> (?:
            \s* (?: [^<>=$\s\\]+ | (?:\\.)+ | [=$]+ (?! [>]) )
        )* )
        >
        (?! [>=])
    name: string.quoted.angle.perl
-
    begin: |
        (?x)
        \b (format)
        #
        # format picture - copied from variable
        (?: \s+ ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*) )?
        #
        \s* = \s* $
    captures:
        1: { name: keyword.function.format.perl }
        2: { name: constant.language.filehandle.picture.perl }
    end: |-
        ^\.\s*$
    name: meta.format.perl
    contentName: string.unquoted.format.perl
    patterns:
    - include: '#line_comment'
    - include: '#variable'
-
    captures:
        1: { name: keyword.function.format.perl }
        2: { name: constant.language.filehandle.picture.perl }
    match: |
        (?x)
        # this pattern will match until the begin/end pattern above matches
        # so that format PICTURE highlights before you put the = in
        #
        \b (format)
        #
        (?:
            \s+
            # format picture - copied from variable
            ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
            \s* $
        )?
-
    captures:
        1: { name: keyword.control.package.perl }
        2: { name: constant.language.package.perl }
    match: |
        (?x)
        \b (
            # autoquoting keywords
            (?:package|use|require|no)
            (?!\w|::)
        )
        #
        (?:\s+(
            # not a version number
            (?!(v\d+(?:\.\d+)*)(?!\w|::))
            #
            # package name - copied from variable
            (?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*
            (?!\w|::)
        ))?
    name: meta.class.perl
-
    captures:
        1: { name: keyword.control.sub.perl }
        2: { name: support.function.control.non-standard-sub.perl }
        3: { name: entity.name.function.perl }
        4: { name: storage.type.method.perl }
    match: |
        (?x)
        \b (?:
            (sub)
        |
            # non-standard sub definitions
            (method|func|before|after|around|trigger|build|set)
        ) (?!\w|:)
        #
        # sub name - copied from variable
        (?:\s+( (?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)* (?!\w|::) ))?
        #
        # prototype - can contain anything but brackets
        (\s* \( [^()]* \))?
    name: meta.function.perl
-
    match: |-
        \b(AUTOLOAD|BEGIN|CHECK|END|INIT|UNITCHECK)(?!\w|::)
    name: meta.function.perl
    captures:
        1: { name: entity.name.function.perl }
-
    captures:
        1: { name: keyword.function.filehandle.perl }
        2: { name: constant.language.filehandle.perl }
        3: { name: constant.language.filehandle.perl }
    match: |
        (?x)
        \b (accept|pipe|socketpair) (?!\w|::)
        #
        # open parens or space
        (?: \s+ | \s*(?: \(\s* )+ )
        #
        (?:
            # filehandle name - copied from variable
            (?![\w&&\P{Lower}]*+[\p{Lower}]) # can't have lowercase letter
            ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
            (?!\w|::|\s*\()
        )
        (?!\w|::)
        #
        \s*,\s*
        # second filehandle name
        (?![\w&&\P{Lower}]*+[\p{Lower}]) # can't have lowercase letter
        ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
        (?!\w|::|\s*\()
    name: meta.function.filehandle.two.perl
-
    captures:
        1: { name: keyword.function.filehandle.perl }
        2: { name: constant.language.filehandle.perl }
    match: |
        (?x)
        # all of these functions take a bareword as the first argument
        \b (accept|bind|binmode|chdir|close|closedir|connect|eof|fcntl|fileno|flock|formline|getc|getpeername|getsockname|getsockopt|ioctl|listen|lstat|open|opendir|pipe|print|printf|read|readdir|readline|recv|rewinddir|say|seek|seekdir|select|send|setsockopt|shutdown|socket|socketpair|stat|sysopen|sysread|sysseek|syswrite|tell|telldir|truncate|write) (?!\w|::)
        #
        (?:
            # open parens or space
            (?: \s+ | \s*(?: \(\s* )+ )
            #
            # filehandle name - copied from variable
            (?![\w&&\P{Lower}]*+[\p{Lower}]) # can't have lowercase letter
            ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
            (?!\w|::|\s*\()
        )?
    name: meta.function.filehandle.perl
-
    match: |-
        \b(ARGV|ARGVOUT|STDERR|STDIN|STDOUT|DATA)(?!\w|::)
    name: constant.language.filehandle.keyword.perl
-
    match: |-
        \b(abs|accept|alarm|and|atan2|bind|binmode|bless|break|caller|chdir|chmod|chomp|chop|chown|chr|chroot|close|closedir|cmp|connect|continue|cos|crypt|dbmclose|dbmopen|default|defined|delete|die|do|dump|each|else|elsif|endgrent|endhostent|endnetent|endprotoent|endpwent|endservent|eof|eq|eval|evalbytes|exec|exists|exit|exp|fc|fcntl|fileno|flock|for|foreach|fork|format|formline|ge|getc|getgrent|getgrgid|getgrnam|gethostbyaddr|gethostbyname|gethostent|getlogin|getnetbyaddr|getnetbyname|getnetent|getpeername|getpgrp|getppid|getpriority|getprotobyname|getprotobynumber|getprotoent|getpwent|getpwnam|getpwuid|getservbyname|getservbyport|getservent|getsockname|getsockopt|given|glob|gmtime|goto|grep|gt|hex|if|index|int|ioctl|join|keys|kill|last|lc|lcfirst|le|length|link|listen|local|localtime|lock|log|lstat|lt|m|map|mkdir|msgctl|msgget|msgrcv|msgsnd|my|ne|next|no|not|oct|open|opendir|or|ord|our|pack|package|pipe|pipe|pop|pos|print|printf|prototype|push|q|qq|qr|quotemeta|qw|qx|rand|read|readdir|readline|readlink|readpipe|recv|redo|ref|rename|require|reset|return|reverse|rewinddir|rindex|rmdir|s|say|scalar|seek|seekdir|select|semctl|semget|semop|send|setgrent|sethostent|setnetent|setpgrp|setpriority|setprotoent|setpwent|setservent|setsockopt|shift|shmctl|shmget|shmread|shmwrite|shutdown|sin|sleep|socket|socketpair|socketpair|sort|splice|split|sprintf|sqrt|srand|stat|state|study|sub|substr|symlink|syscall|sysopen|sysread|sysseek|system|syswrite|tell|telldir|tie|tied|time|times|tr|truncate|uc|ucfirst|umask|undef|unless|unlink|unpack|unshift|untie|until|use|utime|values|vec|wait|waitpid|wantarray|warn|when|while|write|x|xor|y)(?!\w|::)
    name: keyword.function.perl
-
    captures:
        1: { name: constant.language.package.perl }
        2: { name: punctuation.definition.operator.arrow.perl }
        3: { name: support.function.method.perl }
    match: |
        (?x)
        # bareword - copied from variable
        ((?<![\w:])(?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*(?![\w:]) \s*)?
        #
        (->) \s*
        #
        # bareword - copied from variable
        ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*(?![\w:]))?
    name: meta.operator.arrow.perl
-
    match: |
        (?xi)
        \b(0b[01_]+)(?!\w)
    name: punctuation.definition.number.binary.perl
-
    match: |
        (?xi)
        \b(0x[\d_a-f]+)(?!\w)
    name: punctuation.definition.number.hex.perl
-
    match: |
        (?xi)
        \b(0[0-7_]+)(?!\w)
    name: punctuation.definition.number.octal.perl
-
    match: |
        (?xi)
        (?:
            (?:
                # start with digit
                \b (?:
                    [1-9] [\d_]* \.?
                    |
                    # if the digit is 0 it must have a point after it otherwise its octal
                    0 (?: \. | (?![\d_]) )
                )
                |
                # start with point
                \B \. \d
            )
            [\d_]*
            (?: e [+-]? [\d_]+ )?  # possible exponent
        )
        (?!\w)
    name: punctuation.definition.number.float.perl
-
    match: |
        (?x)
        \b (
            v \d[\d_]+ (?:\.\d[\d_]+)*  # v with 1 or more digit groups
            |
            (?:0\b | [1-9]) (?:\.\d[\d_]+){2,} # no v with 3 or more digit groups
        )
        (?!\w)
    name: string.number.version.perl
-
    match: |
        (?x)
        (?:\b\d|\B\.\d)(?:\.(?!\.)|\w+)*
    name: invalid.illegal.number.perl
-
    captures:
        1: { name: keyword.operator.filetest.perl }
        2: { name: constant.language.filehandle.perl }
    match: |
        (?x)
        (?<!\w) (-[rwxoRWXOezsfdlpSbctugkTBMAC]) (?!\w|::)
        #
        (?:
            # open parens or space
            (?: \s+ | \s*(?: \(\s* )+ )
            #
            # filehandle name - copied from variable
            (?![\w&&\P{Lower}]*+[\p{Lower}]) # can't have lowercase letter
            ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
            (?!\w|::|\s*\()
        )?
    name: meta.operator.filetest.perl
-
    match: |-
        (?<!\w)-[\w&&\D]\w*(?!\w|::)
    name: constant.language.string.perl
-
    match: |-
        \b([\w&&\D&&\P{Lower}][\w&&\P{Lower}]*):(?!:)
    name: constant.language.label.perl
-
    captures:
        1: { name: support.function.control.perl }
        2: { name: constant.language.package.perl }
    match: |
        (?x)
        \b (
            # any name
            (?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*
            (?!\w|::)
        )
        \s+
        # not a version number
        (?!(?:v\d+(?>\.\d+)*)(?!\w|::))
        #
        # followed by filehandle - copied from variable
        (?=[\w:'&&\P{Lower}]*+[\p{Lower}]) # must have a lowercase letter
        (?=[\w:'&&\P{Upper}]*+[\p{Upper}]) # must have an uppercase letter
        ((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)
        (?!\w|::|\()
    name: meta.class.perl
-
    match: |-
        (?<!\w|::)((?:(?:::)+|[\w&&\D])\w*(?:(?:::|'[\w&&\D])\w*)*)(?!\w|::)
    name: support.function.bareword.perl
repository:
    ampersand_sub:
        patterns:
        -
            match: |-
                &&
            name: punctuation.definition.operator.boolean.and
        -
            match: |
                (?x)
                [&]
                (
                    [^{\w\s] (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    [^{\w\s]
                    \}
                )
            name: support.function.ampersand.punctuation
        -
            match: |
                (?x)
                [&]
                (?:
                    (?: ::)* \d+ (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?: ::)* \d+
                    \s* \}
                )
            name: support.function.ampersand.digits
        -
            match: |
                (?x)
                [&]
                (?:
                    \^[\w&&\D&&\P{Lower}] \b
                |
                    \{
                    \^[\w&&\D&&\P{Lower}]\w*
                    \}
                )
            name: support.function.ampersand.caret
        -
            match: |
                (?x)
                [&]
                (?:
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    \s* \}
                )
            name: support.function.ampersand.normal
    escaped_char:
        match: |-
            \\.
        name: string.character.escape.perl
    line_comment:
        patterns:
        -
            captures:
                1: { name: comment.line.number-sign.perl }
                2: { name: punctuation.definition.comment.perl }
            match: |-
                ^((#).*$\n?)
            name: meta.comment.full-line.perl
        -
            captures:
                1: { name: punctuation.definition.comment.perl }
            match: |-
                (#).*$\n?
            name: comment.line.number-sign.perl
    nested_braces:
        begin: '\{'
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '\}'
        patterns:
        - include: '#escaped_char'
        - include: '#nested_braces'
    nested_braces_interpolated:
        begin: '\{'
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '\}'
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_braces_interpolated'
    nested_brackets:
        begin: '\['
        captures:
            1: { name: punctuation.section.scope.perl }
        end: ']'
        patterns:
        - include: '#escaped_char'
        - include: '#nested_brackets'
    nested_brackets_interpolated:
        begin: '\['
        captures:
            1: { name: punctuation.section.scope.perl }
        end: ']'
        patterns:
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_brackets_interpolated'
    nested_ltgt:
        begin: '<'
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '>'
        patterns:
        - include: '#nested_ltgt'
    nested_ltgt_interpolated:
        begin: '<'
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '>'
        patterns:
        - include: '#variable'
        - include: '#nested_ltgt_interpolated'
    nested_parens:
        begin: '\('
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '\)'
        patterns:
        - include: '#escaped_char'
        - include: '#nested_parens'
    nested_parens_interpolated:
        begin: '\('
        captures:
            1: { name: punctuation.section.scope.perl }
        end: '\)'
        patterns:
        -
            comment: This is to prevent thinks like qr/foo$/ to treat $/ as a variable
            match: |-
                \$(?=[^\s\w\'\{\[\(\<])
            name: keyword.control.anchor.perl
        - include: '#escaped_char'
        - include: '#variable'
        - include: '#nested_parens_interpolated'
    other_sigil:
        patterns:
        -
            match: |
                (?x)
                [%*]
                (
                    [^{\w\s] (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    [^{\w\s]
                    \}
                )
            name: support.other.sigil.punctuation
        -
            match: |
                (?x)
                [%*]
                (?:
                    (?: ::)* \d+ (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?: ::)* \d+
                    \s* \}
                )
            name: support.other.sigil.digits
        -
            match: |
                (?x)
                [%*]
                (?:
                    \^[\w&&\D&&\P{Lower}] \b
                |
                    \{
                    \^[\w&&\D&&\P{Lower}]\w*
                    \}
                )
            name: support.other.sigil.caret
        -
            match: |
                (?x)
                [%*]
                (?:
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    \s* \}
                )
            name: support.other.sigil.normal
    pod:
        patterns:
        -
            begin: |-
                ^(=)(?=\w)(?!cut\b)
            captures:
                0: { name: punctuation.definition.comment.perl }
            end: |-
                ^(=cut)\b
            name: comment.block.documentation.pod
            patterns:
            -
                match: '\t+'
                name: invalid.pod.tab
    variable:
        patterns:
        -
            match: |
                (?x)
                [@$] \s*
                (
                    [^{\w\s] (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    [^{\w\s]
                    \}
                )
            name: support.other.variable.perl.punctuation
        -
            match: |
                (?x)
                [@$] \s*
                (?:
                    (?: ::)* \d+ (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?: ::)* \d+
                    \s* \}
                )
            name: support.other.variable.perl.digits
        -
            match: |
                (?x)
                [@$] \s*
                (?:
                    \^[\w&&\D&&\P{Lower}] \b
                |
                    \{
                    \^[\w&&\D&&\P{Lower}]\w*
                    \}
                )
            name: support.other.variable.perl.caret
        -
            match: |
                (?x)
                (?: [@$] \s* | \$\# )
                (?:
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    (?!\w|::)
                |
                    # same thing but with braces
                    \{ \s*
                    (?:
                        (?: ::)+
                    |
                        [\w&&\D]
                    ) \w*
                    (?:
                        (?:
                            ::
                        |
                            '[\w&&\D]
                        ) \w*
                    )*
                    \s* \}
                )
            name: support.other.variable.perl.normal
    regex_quantifier_curly:
        patterns:
        -
            match: |
                (?x)
                {(?:
                    \d+,
                    |
                    (?>0*(?=\d)) # skip 0s
                    (?<balanced_digits>
                        \d
                        (?:
                            \g<balanced_digits>
                            |             # can't get any more balanced digits so we're innermost
                            , (?![^,]*+,) # only 1 comma is allowed
                            (?>0*(?=\d))  # skip 0s after comma
                        )?+
                        \d
                    )
                    \d+
                )}
            name: string.quoted.double.perl
        % for my $n (1..10) {
        -
            begin: |
                (?x)
                (?=
                    {
                    (?>0*(?=\d))<%= '(\d)' x $n %> , (?>0*(?=\d))\d{<%= $n %>}
                    }
                )
            end: |
                (?x)
                ({
                \d*+ , (?>0*(?=\d))
                <%= join "", map "(?:[^0-\\$_]|\\$_ ", 1..$n
                %><%= ')' x $n %>
                \d*
                }) | ({\d*,\d*})
            endCaptures:
                1: { name: string.quoted.double.perl }
                2: { name: constant.language.nope }
        % }
...
