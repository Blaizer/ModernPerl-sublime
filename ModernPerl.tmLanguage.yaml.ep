%#
%# This is Extended Perl (EP) but you should view it with a YAML syntax highlighter
%# EP is a template language that lets us use Perl to preprocess text (in this case YAML)
%# For a guide to EP, see http://mojolicio.us/perldoc/Mojolicious/Guides/Rendering#Embedded_Perl
%#
---
name: ModernPerl
scopeName: source.perl
comment: Blaise Roth <blaizer@cpan.org>
uuid: 2c338cc8-a464-4ee4-a56c-d524947fa6f9
fileTypes:
- pl
- pm
- pod
- t
firstLineMatch: |-
    ^#!.*\bperl\b
patterns:
- include: '#line_comment'
- include: '#pod'
-
    match: |-
        [%&*/]=|&&|\*\*|//
    comment: >-
        These would otherwise be highlighted as variables or regex,
        but they're more likely to be an operator.
-
    match: |
        (?x)
        ( & \g<identifier> )
        |
        (
            \$\# (?:\$\s*)* \g<normal_identifier>
            |
            (?: [@$] \s* | [%*] )
            (?<identifier>
                (?:\$\s*)*
                (?:
                    # digit variable like $2
                    (
                        \d+
                        |
                        (?:::)+ \d+ (?!\w|::|'[^\W\d])
                    )
                    |
                    { \s* \g<-1> \s* }
                |
                    (?<normal_identifier> # normal variable like $foo::bar'baz
                        (
                            (?:
                                (?:::|'?[^\W\d]) \w*
                            )++
                        )
                        |
                        { \s* \g<-1> \s* }
                    )
                |
                    # caret variable like $^W or ${^Word}
                    (\^ [^\W\d\p{Lower}])
                    |
                    { \s* \g<-1> \w* \s* }
                |
                    # punctuation variable like $[
                    ([^[^!-~]{\w\s])
                    |
                    { \s* \g<-1> \s* }
                )
            )
        |
            [@$] \s*
        )
    captures:
        1: { name: support.function.ampersand.perl }
        2: { name: punctuation.definition.var.perl }
-
    match: |-
        (-?\b[^\W\d]\w*+)\s*+=>
    captures:
        1: { name: constant.language.string.perl }
    comment: >-
        Turns out this operator needs to be really high up.
        It always autoquotes word characters. It even autoquotes q=>=,
        making it almost impossible to have a literal > at position 0 of a q==!
        There is a way, though! CORE::q=>=. There's always a way!
<%
for (
    [ 'qw?', "(')", 'meta.string.q.perl',  'string.quoted.single.perl', 'single' ],
    [ 'qq',  '(")', 'meta.string.qq.perl', 'string.quoted.double.perl', 'double' ],
    [ 'qx',  '(`)', 'meta.string.qx.perl', 'string.interpolated.perl',  'double', 'single' ],
    [ 'qr',  undef, 'meta.regexp.qr.perl', 'string.regexp.perl',        'double', 'single',   'adilmopsux' ],
    [ 'm',   <<'#', 'meta.regexp.m.perl',  'string.regexp.perl',        'double', 'single', 'acdgilmopsux' ],
# Guessing whether a / is a division or the start of a regex is pretty tricky!
        (?=\s*/) # optimisation to fail faster
        (?:
            # punctuation to expect before a /regex/
            (?<=\W)
            (?:
                (?<=
                    # binding operators - definitely a regex
                    [=!~]~
                    |
                    # probably a regex
                    [,;!({\[] | => | && | \|\|
                )
                |
                # assignment - but not a mutator, comparison, or variable
                (?<= = )
                (?<! [*/'%'x+\-.=!<>&|^@$] = )
            )
        |
            # named operators you'd expect before a /regex/
            (?<=\w)
            (?:
                # never gonna be perfect with the limitations of lookbehinds, but this is close
                # TODO: recognise CORE:: here?
                (?<= if | or )                           (?<! [\w@$&*'%'].{2} | ::.{2} )
                |
                (?<= and | die | for | not | say | xor ) (?<! [\w@$&*'%'].{3} | ::.{3} )
                |
                (?<= exit | warn | when )                (?<! [\w@$&*'%'].{4} | ::.{4} )
                |
                (?<= print | split | until | while )     (?<! [\w@$&*'%'].{5} | ::.{5} )
                |
                (?<= return | unless )                   (?<! [\w@$&*'%'].{6} | ::.{6} )
                |
                (?<= defined | foreach )                 (?<! [\w@$&*'%'].{7} | ::.{7} )
            )
        )
        \s*+ (\/)
        |
        # otherwise we can try for a single line /regex/ if it's after space
        (\/) (?<=\s/|^/)
        (?=
            (?:
                # something like / / is pretty common
                \s+
                |
                # this means no spaces at the start or end unless they're backslashed
                # so /\ woo regex\ / works
                (?!\s) (?: [^\\/] | \\. )* (?: [^\s\\/] | \\. )
            )
            \/
        )
#
) {
    my ($keyword, $quote, $meta, $scope, $include, $single, $modifiers) = @$_;
%>\
-
    begin: |
        (?x)
        \b ( (?:CORE::)? <%= $keyword %> ) \s*
        (?:
            ( (\() | (<) | (\[) | ({) ) | ([^[^!-~]\w\s])
        )
        % if (defined $quote) { chomp $quote;
        |
        <%= $quote %>
        % }
    end: |
        (?x)
        (?:
            % { my $q = defined $quote ? '\8' : '';
            % $q .= '\9' if $keyword =~ /m/;
            ((?!\3)\)|(?!\4)>|(?!\5)\]|(?!\6)\})
            |
            ([\7<%=$q%>[&&]])
            % }
        )
        % if (defined $modifiers) {
        ([<%= $modifiers %>]*) \w*
        % }
    name: <%= $meta %>
    beginCaptures:
        1: { name: keyword.operator.perl }
        # 2: { name: punctuation.definition.string.pair.perl }
        7: { name: punctuation.definition.string.begin.perl }
        % if (defined $quote) {
        8: { name: punctuation.definition.string.begin.perl }
        % } if ($keyword =~ /m/) {
        9: { name: punctuation.definition.string.begin.perl }
        % }
    % if (defined $scope) {
    contentName: <%= $scope %>
    % }
    endCaptures:
        # 1: { name: punctuation.definition.string.pair.perl }
        2: { name: punctuation.definition.string.end.perl }
        % if (defined $modifiers) {
        3: { name: keyword.operator.modifier }
        % }
    patterns:
    % if (defined $single) {
    -
        begin: |-
            (?<=')
        end: |-
            (?=')
        patterns:
        - include: '#<%= $single %>'
    % }
    - include: '#<%= $include %>'
% }
% our ($open, $close, $bopen, $bclose);
% our $i = 0;
% sub quote_characters;
<%
for (
    [ 's',        'meta.regexp.s.perl', 'double_or_single_regexp', 'double_or_single', 'acdegilmoprsux' ],
    [ '(?:tr|y)', 'meta.tr.perl',       'double_or_single',        'double_or_single',           'cdrs' ],
) {
    my ($keyword, $meta, $first_include, $second_include, $modifiers) = @$_;
%>\
-
    begin: |-
        (?x) \b (?= ( (?:CORE::)? <%= $keyword %> ) \s* ([^[^!-~]\w\s]) )
    end: |-
        (?!\b\1\s*\2)
    name: <%= $meta %>
    patterns:
    % while (quote_characters) {
    % if ($bopen) {
    -
        begin: |-
            (?x) ( (?:CORE::)?+ \w+ ) \s* (<%= $bopen %>)
        end: |
            (?x)
            (?<!<%= $bopen %>)(?!<%= $bclose %>)
            (?:
                (?<!<%= $bclose %>|^)
                (?:
                    (?<![^\W[<%= $modifiers %>]])
                    ([<%= $modifiers %>]*)
                )?
                \w*
            )?
        beginCaptures:
            1: { name: keyword.operator.perl }
            # 2: { name: punctuation.definition.string.pair.perl }
        endCaptures:
            1: { name: keyword.operator.modifier.perl }
        patterns:
        -
            begin: |-
                (?x) (<%= $bclose %>) (?: \s+ (\#.*) )? \s* \n
            end: |
                (?x)
                (?:
                    (?<=\S)
                    |
                    (?= ^ \s*+ [[^!-~]\w] )
                )
                (?:
                    (?<=<%= $bclose %>)
                    (?: ([<%= $modifiers %>]) | \w )
                )?
                <%= $bclose %>*
            beginCaptures:
                # 1: { name: punctuation.definition.string.pair.perl }
                2: { name: comment.line.number-sign.perl }
            endCaptures:
                1: { name: keyword.operator.modifier.perl }
            patterns:
            -
                match: |-
                   (?x) ^ \s* (\#.*)? \n
                captures:
                    1: { name: comment.line.number-sign.perl }
            -
                begin: |
                    (?x)
                    ^ \s*
                    (?:
                        ( (\() | (<) | (\[) | ({) ) | ([^[^!-~]\w\s])
                    )
                end: |-
                    ((?!\2)\)|(?!\3)>|(?!\4)\]|(?!\5)\})|([\6[&&]])
                beginCaptures:
                    # 1: { name: punctuation.definition.string.pair.perl }
                    6: { name: punctuation.definition.string.begin.perl }
                endCaptures:
                    # 1: { name: punctuation.definition.string.pair.perl }
                    2: { name: punctuation.definition.string.end.perl }
                patterns:
                - include: '#<%= $second_include %>'
        -
            begin: |
                (?x)
                (<%= $bclose %>) \s*
                (?:
                    ( (\() | (<) | (\[) | ({) ) | ([^[^!-~]\w\s])
                )
            end: |
                (?x)
                (?:
                    ((?!\3)\)|(?!\4)>|(?!\5)\]|(?!\6)\})|([\7[&&]])
                )
                (?:
                    (?<=<%= $bclose %>)
                    (?: ([<%= $modifiers %>]) | \w )
                )?
                <%= $bclose %>*
            beginCaptures:
                # 1: { name: punctuation.definition.string.pair.perl }
                # 2: { name: punctuation.definition.string.pair.perl }
                7: { name: punctuation.definition.string.begin.perl }
            endCaptures:
                # 1: { name: punctuation.definition.string.pair.perl }
                2: { name: punctuation.definition.string.end.perl }
                3: { name: keyword.operator.modifier.perl }
            patterns:
            - include: '#<%= $second_include %>'
        -
            match: |-
                (<%= $bclose %>)
            # captures:
                # 1: { name: punctuation.definition.string.pair.perl }
        -
            begin: |-
                (?<=<%= $bopen %>)
            end: |-
                (?=<%= $bclose %>)
            patterns:
            - include: '#<%= $first_include %>'
    % } else {
    -
        begin: |-
            (?x) (?= (?:CORE::)?+ \w+ \s* <%= $open %> )
        end: |-
            (?x) (<%= $open %>) ([<%= $modifiers %>]*) \w*
        endCaptures:
            1: { name: punctuation.definition.string.end.perl }
            2: { name: keyword.operator.modifier.perl }
        patterns:
        -
            begin: |-
                (?x) ( (?:CORE::)?+ \w+ ) \s* (<%= $open %>)
            end: |
                (?x)
                ((<%= $open %>))
                (?:
                    (?! \g<4> <%= $open %> )
                    |
                    (?<=')(\g<4>)
                    |
                    ( \w+ \s* )
                )
            beginCaptures:
                1: { name: keyword.operator.perl }
                2: { name: punctuation.definition.string.begin.perl }
            endCaptures:
                1: { name: punctuation.definition.string.begin.perl }
                2: { name: punctuation.definition.string.end.perl }
                3: { name: string.quoted.single.perl }
                4: { name: string.quoted.double.perl }
            patterns:
            - include: '#<%= $first_include %>'
        -
            begin: |-
                (?<=<%= $open %>)
            end: |-
                (?=<%= $open %>)
            patterns:
            - include: '#<%= $second_include %>'
    % }
    % }
% }
- include: '#heredoc_1'
-
    match: |
        (?x)
        <
        (?<! <<)
        (?! [\s=])
        (
            (?:
                \s* (?: [^<>=$\s\\]+ | \\. | [=$] (?! [>]) )
            )*+
        )
        >
        (?! [>=])
    name: meta.string.glob
    captures:
        1: { name: string.quoted.other.glob.perl }
-
    match: |
        (?x)
        {(
            \s* (-?[^\W\d]\w*)
        |
            \g<-1> \s*
        )}
    captures:
        1: { name: constant.language.string.perl }
-
    match: |-
        \b(?:CORE::)?__(?:FILE|LINE|PACKAGE|SUB)__(?!\w|::|'[^\W\d])
    name: keyword.function.compiler.perl
-
    match: |
        (?x)
        \b ( (?:CORE::)? (?:dump|goto|last|next|redo) )
        #
        (?:
            # open parens or space
            (?: \s* (?:\(\s*)+ | \s+ )
            #
            # LABEL
            ([^\W\d\p{Lower}][^\W\p{Lower}]*)
        )?
        #
        (?!\w|::|'[^\W\d])
    name: meta.control.labelled.perl
    captures:
        1: { name: keyword.control.perl }
        2: { name: constant.language.label.perl }
-
    match: |-
        \b(?:CORE::)?(?:break|continue|default|dump|else|elsif|for|foreach|given|goto|if|last|next|redo|return|unless|until|when|while)(?!\w|::|'[^\W\d])
    name: keyword.control.perl
-
    match: |-
        \b(?:CORE::)?(?:do|eval)(?=\s*{)
    name: keyword.control.perl
-
    match: |-
        (\b(?:CORE::)?(?:local|my|our|state)(?!\w|::|'[^\W\d]))
    name: storage.modifier.perl
    captures:
        0: { name: variable.parameter.perl }
        1: { name: variable.other.readwrite.global.perl }
-
    match: |-
        \b(?:CORE::)?(?:m|q|qq|qr|qw|qx|s|tr|y)\b
    name: keyword.operator.perl
-
    match: |-
        \b(?:CORE::)?(?:and|cmp|or|xor|not|lt|gt|le|ge|eq|ne|x)(?!\w|::|'[^\W\d])
    name: keyword.operator.perl
-
    begin: |-
        \b(?:CORE::)?__(?:END|DATA)__(?!\w|::|'[^\W\d])
    end: |-
        (?!) # the end has no end
    name: comment.block.other.perl
    patterns:
    - include: '#pod'
-
    begin: |
        (?x)
        \b ( (?:CORE::)? format )
        #
        (?:
            # format picture - copied from variable
            (?: \s+
                ((?!')(?:(?:::|'?[^\W\d])\w*+)++)
                (?= \s* (?:=\s*)? $ )
            )
        |
            (?!\w|::|'[^\W\d])
        )
    end: |
        (?x)
        (?! \s* (?:=\s*)? $ )
        |
        ^\.\s*$
    name: meta.format.perl
    beginCaptures:
        1: { name: keyword.function.perl }
        2: { name: constant.language.filehandle.picture.perl }
    patterns:
    -
        begin: |-
            =\s*
        end: |-
            (?=^\.\s*$)
        contentName: string.unquoted.format.perl
        patterns:
        - include: '#line_comment'
        - include: '#variable'
-
    match: |
        (?x)
        # autoquoting keywords
        \b ( (?:CORE::)? (?:package|use|require|no) ) \s+
        (
            # not a version number
            (?!v\d)
            #
            # package name - copied from variable
            (?!')(?:(?:::|'?[^\W\d])\w*)+
        )
    name: meta.package.perl
    captures:
        1: { name: keyword.control.perl }
        2: { name: constant.language.package.perl }
-
    begin: |
        (?x)
        \b (?:
            ( (?:CORE::)? sub )
        |
            # non-standard sub definitions
            (method|func|before|after|around|trigger|build|set)
        )
        #
        # sub name - copied from variable
        (?:
            \s+ (
                (?!')(?:(?:::|'?[^\W\d])\w*+)++
            )
            |
            (?!\w|::|'[^\W\d])
        )
    end: |
        (?x)
        (?! \s* [(] | \s* $ )
        |
        (?<= [)] )
    name: meta.function.perl
    beginCaptures:
        1: { name: keyword.control.perl }
        2: { name: support.function.perl }
        3: { name: entity.name.function.perl }
    patterns:
    -
        begin: '\('
        end: '\)'
        contentName: storage.type.method.perl
        patterns:
        - include: '#single'
-
    match: |-
        \b(?:CORE::)?(?:AUTOLOAD|BEGIN|CHECK|END|INIT|UNITCHECK)(?!\w|::|'[^\W\d])
    name: meta.function.perl
    captures:
        0: { name: entity.name.function.perl }
-
    match: |
        (?x)
            # these functions can take two filehandles as arguments
            \b ( (?:CORE::)? (?:accept|pipe|socketpair) ) \g<5>
            (\g<6>) \s*,\s* (\g<6>)
        |
            # these functions take a filehandle as the first argument
            (
                \b (?:CORE::)? (?:accept|bind|binmode|chdir|close|closedir|connect|eof|fcntl|fileno|flock|formline|getc|getpeername|getsockname|getsockopt|ioctl|listen|lstat|open|opendir|pipe|print|printf|read|readdir|readline|recv|rewinddir|say|seek|seekdir|select|send|setsockopt|shutdown|socket|socketpair|stat|sysopen|sysread|sysseek|syswrite|tell|telldir|truncate|write)
            |
                # filetest operators
                -[ABCMORSTWXbcdefgkloprstuwxz] (?<! \w.. )
            )
            (
                (?!\w|::|'[^\W\d])
                # open parens or space
                (?: \s* (?:\(\s*)+ | \s+ )
            )
            (
                # filehandle name - uppercase only
                (?!')(?:(?:::|'?[^\W\d\p{Lower}])[^\W\p{Lower}]*+)++
                (?!\w|::|'[^\W\d]|\s*\()
            )
    name: meta.function.filehandle.perl
    captures:
        1: { name: keyword.function.perl }
        2: { name: constant.language.filehandle.perl }
        3: { name: constant.language.filehandle.perl }
        4: { name: keyword.function.perl }
        6: { name: constant.language.filehandle.perl }
-
    match: |
        (?x)
        (?:
            \b (?:CORE::)? (?:
                abs|accept|alarm|and|atan2|bind|binmode|bless|break|caller|chdir|chmod|chomp|chop|chown|chr|chroot|close|closedir|cmp|connect|continue|cos|crypt|dbmclose|dbmopen|default|defined|delete|die|do|dump|each|else|elsif|endgrent|endhostent|endnetent|endprotoent|endpwent|endservent|eof|eq|eval|evalbytes|exec|exists|exit|exp|fc|fcntl|fileno|flock|for|foreach|fork|format|formline|ge|getc|getgrent|getgrgid|getgrnam|gethostbyaddr|gethostbyname|gethostent|getlogin|getnetbyaddr|getnetbyname|getnetent|getpeername|getpgrp|getppid|getpriority|getprotobyname|getprotobynumber|getprotoent|getpwent|getpwnam|getpwuid|getservbyname|getservbyport|getservent|getsockname|getsockopt|given|glob|gmtime|goto|grep|gt|hex|if|index|int|ioctl|join|keys|kill|last|lc|lcfirst|le|length|link|listen|local|localtime|lock|log|lstat|lt|m|map|mkdir|msgctl|msgget|msgrcv|msgsnd|my|ne|next|no|not|oct|open|opendir|or|ord|our|pack|package|pipe|pop|pos|print|printf|prototype|push|q|qq|qr|quotemeta|qw|qx|rand|read|readdir|readline|readlink|readpipe|recv|redo|ref|rename|require|reset|return|reverse|rewinddir|rindex|rmdir|s|say|scalar|seek|seekdir|select|semctl|semget|semop|send|setgrent|sethostent|setnetent|setpgrp|setpriority|setprotoent|setpwent|setservent|setsockopt|shift|shmctl|shmget|shmread|shmwrite|shutdown|sin|sleep|socket|socketpair|sort|splice|split|sprintf|sqrt|srand|stat|state|study|sub|substr|symlink|syscall|sysopen|sysread|sysseek|system|syswrite|tell|telldir|tie|tied|time|times|tr|truncate|uc|ucfirst|umask|undef|unless|unlink|unpack|unshift|untie|until|use|utime|values|vec|wait|waitpid|wantarray|warn|when|while|write|x|xor|y
            )
            |
            -[ABCMORSTWXbcdefgkloprstuwxz] (?<! \w.. )
        )
        (?!\w|::|'[^\W\d])
    name: keyword.function.perl
-
    match: |-
        \b(?:ARGV|ARGVOUT|STDERR|STDIN|STDOUT|DATA)(?!\w|::|'[^\W\d])
    name: constant.language.filehandle.perl
    comment: >-
        These aren't keywords, so CORE:: isn't applicable.
-
    match: |
        (?x)
        # class name
        \b (\g<2>)?
        -> \s*
        #
        # method name
        ((?!')(?:(?:::|'?[^\W\d])\w*+)++)
    name: meta.operator.arrow.perl
    captures:
        1: { name: constant.language.package.perl }
        2: { name: support.function.method.perl }
-
    match: |
        (?xi)
        \b(?:0b[01_]*)(?!\w)
    name: punctuation.definition.number.binary.perl
-
    match: |
        (?xi)
        \b(?:0x[\h_]*)(?!\w)
    name: punctuation.definition.number.hex.perl
-
    match: |
        (?xi)
        \b(?:0[0-7_]+)(?!\w)
    name: punctuation.definition.number.octal.perl
-
    match: |
        (?x)
        \b (?:
            v (\d[\d_]*) (\.\d[\d_]*)* # v with 1 or more digit groups
            |
            (?!0[\d_]) \g<1> \g<2>{2,} # no v with 3 or more digit groups
        )
        (?!\w)
    name: string.other.version.perl
-
    match: |
        (?xi)
        (?:
            (?:
                # start with digit
                \b (?!0[\d_]) \d[\d_]*+ \.?
                |
                # start with point
                \B \. \d
            )
            [\d_]*
            (?: e [+-]? [\d_]* )?  # possible exponent
        )
        (?!\w)
    name: punctuation.definition.number.float.perl
-
    match: |-
        (?:\b\d|\B\.\d)\w*
    name: invalid.illegal.number.perl
-
    match: |-
        \b[^\W\d\p{Lower}][^\W\p{Lower}]*+:(?!:)
    name: constant.language.label.perl
-
    match: |-
        (?=[^[^\w:]\d])(?<!\w)(?:(?:::|'?[^\W\d])\w*)+
    name: support.function.bareword.perl

################################################################################

repository:
<%
sub quote_characters {
    my ($heredoc) = @_;
    {
        $i = ord '!' if !$i;
        $_ = chr $i++;
        $i %= 0x80 + ($heredoc ? 1 : 0);
        return if !$i;
        if ($i == 0x80) {
            $open = $close = $bopen = $bclose = "";
        }
        else {
            redo if /[\w\s]/;
            $open = $close = $bopen = $bclose = $_;
            tr/(<[{//cd for $bopen, $bclose;
            tr/(<[{/)>]}/ for $close, $bclose;
            $_ = quotemeta for $open, $close, $bopen, $bclose;
        }
    }
    return 1;
}

sub bracket_characters {
    return $i = 0 if $i >= 4;
    $open  = $bopen  = quotemeta +(qw' ( < [ { ')[$i];
    $close = $bclose = quotemeta +(qw' ) > ] } ')[$i];
    $i++;
    return 1;
}

sub recursive_brackets {
    my ($name) = @_;
    if ($bopen) {
        return << "";
            -
                { begin: '$bopen', end: '$bclose', patterns: [ include: '#$name' ] }

    }
}

sub quote_begin_end {
    if ($open) {
        return <<"";
            begin: |-
                (?<=$open)
            end: |-
                (?=$close)

    }
    else {
        return <<'';
            begin: '^'
            end: '\n|(?<=\n)'

    }
}

sub e {
    my ($s) = @_;
    for ($s) {
        if ($open or $close) {
            s/([$open$close])/\\$1/g;
        }
        return quotemeta;
    }
}

%>\
    single:
        patterns:
        % while (quote_characters) {
        -
            <%= quote_begin_end =%>
            patterns:
            -
                match: |-
                    (\\)[<%= $open.$bclose %>\\]
                captures:
                    1: { name: constant.character.escape.perl }
            <%= recursive_brackets "single" =%>
        % }
    double:
        patterns:
        % while (quote_characters 1) {
        -
            <%= quote_begin_end =%>
            patterns:
            -
                match: |
                    (?x)
                    (
                        (?: <%=e '$'%> \s* | <%=e '@'%> )
                        (?: \d+ | \w+ )
                        |
                        <%=e '$'%> \s*
                    )
                name: storage.modifier.perl
                captures:
                    0: { name: variable.parameter.perl }
                    1: { name: variable.other.readwrite.global.perl }
            -
                match: |
                    (?x)
                    (\\ (?:
                        x(?: \h{1,2} <%#| {(?!__)[_\h]*}%>)
                        |
                        #o{(?!__)[_0-7]*}
                        #|
                        [0-7]{1,3}
                        |
                        #N{(?: (?!U\+)[^}]* | U\+(?:_?\h+)+ )}
                        #|
                        #c\p{ASCII}
                        #|
                        \p{Alnum}
                    ))
                    |
                    (\\)[\d\D]
                captures:
                    1: { name: constant.character.escape.perl }
                    2: { name: constant.character.escape.perl }
            <%= recursive_brackets "double" =%>
        % }
    double_or_single:
        patterns:
        -
            begin: |-
                (?<=')
            end: |-
                (?=')
            contentName: string.quoted.single.perl
            patterns:
            - include: '#single'
        -
            begin: |-
                (?<=(\()|(<)|(\[)|({)|([^[^!-~]\w\s]))
            end: |-
                (?=(?!\1)\)|(?!\2)>|(?!\3)\]|(?!\4)\}|[\5[&&]])
            contentName: string.quoted.double.perl
            patterns:
            - include: '#double'
    double_or_single_regexp:
        patterns:
        -
            begin: |-
                (?<=')
            end: |-
                (?=')
            contentName: string.regexp.perl
            patterns:
            - include: '#single'
        -
            begin: |-
                (?<=(\()|(<)|(\[)|({)|([^[^!-~]\w\s]))
            end: |-
                (?=(?!\1)\)|(?!\2)>|(?!\3)\]|(?!\4)\}|[\5[&&]])
            contentName: string.regexp.perl
            patterns:
            - include: '#double'
    line_comment:
        match: |-
            (#)[\d\D]*
        name: comment.line.number-sign.perl
        captures:
            1: { name: punctuation.definition.comment.perl }
    pod:
        patterns:
        -
            begin: |-
                ^(?==(?=\p{Alpha})(?!cut(?!\p{Alpha})))
            end: |-
                ^=cut(?!\p{Alpha})[\d\D]*
            name: comment.block.documentation.pod
            patterns:
            -
                match: '\t+'
                name: invalid.deprecated.tab.pod
        -
            match: |-
                ^=cut(?!\p{Alpha})[\d\D]*
            name: comment.block.documentation.pod
    heredoc_1:
        patterns:
        -
            begin: |
                (?x)
                (<<)
                (?:
                    (\w+)
                    |
                    \s* " ([^"]*) "
                    |
                    \s* ` ([^`]*) `
                ) .* \n?
            end: |-
                ^(\2\3)(\4)$
            name: meta.heredoc.perl
            beginCaptures:
                1: { name: punctuation.definition.heredoc.perl }
                2: { name: string.quoted.double.perl }
                3: { name: string.quoted.double.perl }
                4: { name: string.interpolated.perl }
            contentName: string.unquoted.perl
            endCaptures:
                1: { name: string.quoted.double.perl }
                2: { name: string.interpolated.perl }
            patterns:
            - include: '#double'
        -
            begin: |
                (?x)
                (<<)
                (?:
                    \\ (\w+)
                    |
                    \s* ' ([^']*) '
                ) .* \n?
            end: |-
                ^(\2\3)$
            name: meta.heredoc.single.perl
            beginCaptures:
                1: { name: punctuation.definition.heredoc.perl }
                2: { name: string.quoted.single.perl }
                3: { name: string.quoted.single.perl }
            contentName: string.unquoted.perl
            endCaptures:
                1: { name: string.quoted.single.perl }
    regex_quantifier_curly:
        patterns:
        -
            match: |
                (?x)
                {(?:
                    \d+,?
                    |
                    (?>0*(?=\d)) # skip 0s
                    (
                        \d
                        \g<-1>
                        \d
                        |               # can't get any more balanced digits so we're innermost
                        , (?>0*(?=\d))  # skip 0s after comma
                    )
                    \d+
                )}
            name: string.quoted.double.perl
        % for my $n (1..10) {
        -
            begin: |
                (?x)
                (?={
                    (?>0*(?=\d))<%= '(\d)' x $n %> , (?>0*(?=\d))\d{<%= $n %>}
                })
            end: |
                (?x)
                ({
                \d* , (?>0*(?=\d))
                <%= join "", map "(?:[^0-\\$_]|\\$_ ", 1..$n
                %><%= ')' x $n %>
                \d*
                }) | {\d*,\d*}
            endCaptures:
                1: { name: string.quoted.double.perl }
        % }
...
