=head1 NAME

parseplist.pl - parse plist files between XML and YAML

=head1 SYNOPSIS

 perl parseplist.pl [OUTFILE [INFILE]]
 perl parseplist.pl OUTFILE.yaml [INFILE]

=head1 OPTIONS

This script has two different modes. The default mode takes a YAML C<INFILE> and
outputs an XML C<OUTFILE>. In this mode the default C<OUTFILE> is
ModernPerl.tmLanguage and the default C<INFILE> is
ModernPerl.tmLanguage.yaml.ep. If C<INFILE> ends in .ep the Extended Perl will
be rendered to YAML, then saved as C<OUTFILE>.yaml, before being parsed from
YAML to XS as normal. If C<OUTFILE> (or C<OUTFILE>.yaml) exists it will be
overwritten.

When C<OUTFILE> ends in .yaml or .yml the script instead takes an XML C<INFILE>
and outputs a YAML C<OUTFILE>. In this mode the default C<INFILE> is
Perl.tmLanguage. If C<OUTFILE> exists it will never be overwritten. Remove the
file first before running this script.

=head1 DEPENDENCIES

=over

=item YAML

=item Mojolicious (if using .ep C<INFILE>)

=item XML::Parser (if using .yaml C<OUTFILE>)

=back

=cut

use 5.01;
use strict;
use warnings;
use Data::Dumper;
use YAML::Any qw/DumpFile Load/;
use Scalar::Util qw/looks_like_number/;
use autodie;
sub parse;
sub unparse;
sub printout;
sub badprint;

my $outfile = $ARGV[0] // "ModernPerl.tmLanguage";
my $infile  = $ARGV[1];

if ($outfile =~ /\.ya?ml$/i) {
	-e $outfile and exit say "$outfile exists. Won't overwrite.";
	require XML::Parser;
	$infile //= "Perl.tmLanguage";
	my $p = XML::Parser->new(Style => "Tree");
	my $tree = $p->parsefile($#$infile);
	my @parsed = parse @$tree;
	DumpFile $outfile, @parsed;
}
else {
	$infile //= "ModernPerl.tmLanguage.yaml.ep";

	my $yaml;
	if ($infile =~ /.ep$/i) {
		require Mojo::Template;
		my $mt = Mojo::Template->new(auto_escape => 0);
		$yaml = $mt->render_file($infile);
		if (ref $yaml eq "Mojo::Exception") {
			print $yaml->message;
			exit 1;
		}
		my $yamloutfile = "$outfile.yaml";
		printout $yamloutfile, <<"YAML", $yaml;
%YAML 1.1
#
# This file was generated automatically by $0 from $infile.
# Do not edit this file directly. Instead use $0 to generate it.
#
YAML
	}
	else {
		local $/;
		open IN, "<", $infile;
		$yaml = <IN>;
		close IN;
	}

	# search for some common mistakes
	while ($yaml =~
		m{
			\G [\d\D]*? ^
			(
				(\h+) \w+\h*:\h+ ([|>]) (-?) .*\n

 				\2\h+ (\(\? [a-z]*x[a-z-]* \))? .*\n

				(?: \2\h+ .*\n )*
			)
		}gmx
	) {
		my ($lines, $taker, $minus, $x) = ($1, $3, $4, $5);
		my $multiline = $lines =~ /(?:.*\n){3,}/;

		my $bad;
		if ($multiline and !$x and $taker eq "|") {
			$bad = "Can't multiline non x";
		}
		if ($multiline and $taker eq ">" and $x) {
			$bad = "Can't > with multiline x because you can't use comments";
		}
		if ($multiline and $x and $minus) {
			$bad = "Multiline x looks better without -";
		}
		if (!$minus and !$multiline) {
			$bad = "Probably should be using -";
		}
		if ($bad) {
			say $bad;
			badprint $lines;
		}
	}

	my ($tree) = Load $yaml;
	my $xml = unparse $tree, 1;
	printout $outfile, <<"XML", $xml, "</plist>\n";
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<!--
This file was generated automatically by $0 from $infile.
Do not edit this file directly. Instead, use $0 to generate it.
-->
<plist version="1.0">
XML
}

sub printout {
	my $outfile = shift;
	chmod 0666, $outfile if -f $outfile; # read-write
	open OUT, ">", $outfile;
	print OUT @_;
	close OUT;
	chmod 0444, $outfile; # read only
}

sub badprint {
	eval "END { exit 1 }"; # exit 1 on END if we ever reach this code
	print @_;
}

sub unparse {
	my $item = shift;
	my $level = shift;
	my $indent = "\t" x $level;
	my $a = $indent;

	if (!ref $item) {
		my $tag = shift;
		if (!defined $tag) {
			badprint "no tag: " . Data::Dumper->Dump([$item], ["value"]);
			return "";
		}

		$item //= '';
		$item =~ s/(^|\G) {4}/\t/gm; # convert indentation to tabs
		$item =~ s/\n/\n$indent/g;

		my $orig_item = $item;
		$item =~ s/&/&amp;/g;
		$item =~ s/</&lt;/g;
		$item =~ s/>/&gt;/g;
		# use CDATA unless it costs us more characters than not using it
		if (length($item) - length $orig_item >= length "<![CDATA[]]>") {
			$item = "<![CDATA[$orig_item]]>" if $orig_item !~ /]]>/;
		}

		$a .= "<$tag>$item</$tag>";
	}
	elsif (ref $item eq "HASH") {
		$a .= "<dict>\n";
		for my $key (sort keys %$item)
		{
			$a .= unparse $key,          $level + 1, "key";
			$a .= unparse $item->{$key}, $level + 1, $key eq "applyEndPatternLast" ? "integer" : "string";
		}
		$a .= "$indent</dict>";
	}
	elsif (ref $item eq "ARRAY") {
		$a .= "<array>\n";
		for my $value (@$item) {
			$a .= unparse $value, $level + 1, "string";
		}
		$a .= "$indent</array>";
	}
	else {
		badprint "unexpected: " . Data::Dumper->Dump([$item], ["item"]);
		return "";
	}

	return $a . "\n";
}

sub parse {
	return if !@_;
	my @a;

	for (my $i = 0; $i < @_; $i += 4) {
		my $name = $_[$i];
		my $list = $_[$i + 1];

		my (undef, undef, $content, @inner) = @$list;
		if ($name eq "string" or $name eq "key" or $name eq "integer") {
			push @a, $content;
		}
		elsif ($name eq "dict") {
			push @a, { parse @inner };
		}
		elsif ($name eq "array") {
			push @a, [ parse @inner ];
		}
		else {
			badprint "skipped: $name\n";
			push @a, parse @inner;
		}
	}

	return @a;
}
